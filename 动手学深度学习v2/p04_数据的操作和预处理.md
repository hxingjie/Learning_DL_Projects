# 一.数据操作

---

## 1.生成

```python
import torch

x = torch.arange(10)  # 生成1维张量，元素为 [0...10)
print(x)  # tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
print(x.shape)  # torch.Size([10]) 获取张量的形状
print(x.numel())  # 10 获取张量的元素数

# 改变张量
X = x.reshape(2, 5)  # tensor([[0, 1, 2, 3, 4],
#                              [5, 6, 7, 8, 9]])

X = torch.zeros(2, 3, 4)  # 生成全为0的三维张量
X = torch.ones(2, 3, 4)  # 生成全为1的三维张量

X = torch.tensor([[[1, 2, 3],
                   [4, 5, 6]]])  # 生成给定的张量
```

---

## 2.运算

```python
x = torch.tensor([1., 2., 4., 8.])
y = torch.tensor([2., 2., 2., 2.])
print(x + y)
print(x - y)
print(x * y)
print(x / y)
print(x ** y)
print(torch.exp(x))
```

---

## 3. 操作

```python
# 1.合并
X = torch.arange(12, dtype=torch.float32).reshape(3, 4)
Y = torch.tensor([[2., 1., 4., 3.], [1., 2., 3., 4.], [4., 3., 2., 1]])
print(torch.cat((X, Y), dim=0))  # 第0维合并
print(torch.cat((X, Y), dim=1))  # 第1维合并

# 2.通过逻辑运算符获得对应维度的张量
print(X == Y)  
# tensor([[False,  True, False,  True],
#         [False, False, False, False],
#         [False, False, False, False]])

# 3.求和
print(X.sum())  # 返回0维的张量，tensor(66.)

# 4.广播机制
a = torch.arange(3).reshape(3, 1);
b = torch.arange(2).reshape(1, 2);
print(a + b)  
# 形状不相同的两个张量，此时会将a的第二维复制1次，变成（3，2），b的第一维复制三次，变成（3，2）
# a:[[0, 0]    b:[[0, 1]    a+b:[[0, 1]
#		 [1, 1]       [0, 1]         [1, 2]
#    [2, 2]]      [0, 1]]        [2, 3]]

# 5.访问
X = torch.tensor([[1, 2, 3],
                  [4, 5, 6],
                  [7, 8, 9]])

print(X[0]) print(X[-1]) print(X[0:2]) print(X[0:]) print(X[:3])

# 6.插入元素
X[0, 0] = 0
X[0:2, :] = 0  # 0到1行的全部列赋值为0

# 7.内存
before = id(Y)
Y = X + Y
print(id(Y) == before)  # False, 重新创建了张量赋值给Y

before = id(Y)
Y[:] = X + Y
print(id(Y) == before)  # 对Y的每一个元素重新赋值，没有创建新的张量

before = id(Y)
Y += X
print(id(Y) == before)  # 使Y的每一个元素加上X的对应元素，没有创建新的张量

# 8.转换
X = torch.tensor([[1, 2], [3, 4]])
A = X.numpy()
B = torch.tensor(A)
print(type(A), type(B))  # <class 'numpy.ndarray'> <class 'torch.Tensor'>

x = torch.tensor([3.14])
print(x, x.item(), float(x), int(x))
```

